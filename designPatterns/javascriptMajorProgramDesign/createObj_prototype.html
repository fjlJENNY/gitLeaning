<!DOCTYPE html>  
<html lang="en">  
<head>  
    <meta charset="UTF-8">  
    <title>如何创建对象--原型模式</title>
</head>  
<body>
<script type="text/javascript">
    function Person(){}
    Person.prototype.name = "Nick";
    Person.prototype.age = 29;
    Person.prototype.job = "Software Engineer";

    var person1 = new Person();
    /*
       1. 理解person1 , Person 值 // 2.person1 是实例对象,对象类型是Person
    */
    console.log(person1,Person,person1.constructor,Person.prototype.constructor);
    // 实例对象的 constructor ，是 __proto__ 上的 constructor
    //Person{} , function Person(){...}, function Person(){...} , function Person(){...}

    var person2 = new Person();
    person1.name = "Grey";

    console.log(person1.name,person2.name);

    //delete person1.name;
    console.log(person1.name,person2.name);

    /*
        使用 for-in 循环时，返回的是 能够通过对象访问的，可枚举的(enumerable) 属性

        // ? 屏蔽了原型中 不可枚举 属性的实例 也会在 for-in  循环中返回
    */
    // 实例 与 原型 之间的 松散 连接关系 。 原型中重新声明方法 （如下） , 这样实例也是可以访问这个方法。
    Person.prototype.sayHi = function(){
        console.log("hi");
    }
    console.log(person1.sayHi());

    //但是下面这种情况 不适合 上述情况。 （重写整个原型对象 , 见 p156） 

    function Person2(){

    }
    Person2.prototype = {
        constructor:Person2, // -- 设置 constructor (构造函数) 会导致它的Enumerable 属性设置为 true
        name:"Nick",
        age:29,
        job:"software engineer",
        sayName:function(){
            console.log(this.name);
        }
    }

    console.log(Person2.prototype.constructor,{},new Object(),Person2.prototype.constructor === {});


        
    // 【原型方法的缺点(最大问题)】 原型上的属性被 实例共享
    //  这种共享 在 包含引用类型值的属性 。会让引用类型出现错误。

    function Person3(){}
    Person3.prototype.friends = ["a","b"];
    var person11 = new Person3();
    var person22 = new Person3();
    person11.friends.push("c");
    console.log(person22.friends);
    
</script>
</body>  
</html>